// Copyright 2025 UMH Systems GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ---------------------------------------------------------------------------
//
// Tag-Processor → FSM wire contracts
// ----------------------------------
// These messages are emitted by the Benthos **tag_processor** and consumed
// exclusively by the finite-state-machine (FSM) that drives UMH-Core.  Once
// inside the FSM the data is reshaped into other structs, and further hops
// (Communicator → Front-End) use plain JSON, not this protobuf.
//
// Typical flow
//    ┌───────────┐   UnsBundle  (Protobuf + hex)   ┌─────────────┐
//    │ tag_proc. │ ────────────────────────────────►│   FSM       │
//    └───────────┘                                  └─────────────┘
//      UnsBundle.events[*] : EventTableEntry         (~ring-100)
//      UnsBundle.uns_map   : TopicInfo (complete state)
//
// ---------------------------------------------------------------------------

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: topic_browser_data.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// PayloadFormat discriminates between the two payload families for frontend convenience.
// This allows the UI to quickly determine payload type without inspecting the oneof structure.
// Similar to how ScalarType provides quick type information for time-series values.
//
// ▸ TIMESERIES … the classic "one tag, one value, one timestamp" sensor point
// ▸ RELATIONAL  … a complete, self-contained JSON document (batch header,
//
//	alarm object, recipe, …) that already belongs together
//
// Each event emitted by the tag-processor falls into **exactly one** payload
// family. Anything else is rejected at ingest-time; mixing formats on a single topic
// would break the "one-topic-one-shape" contract.
//
// See full rationale at: https://docs.umh.app/usage/unified-namespace/payload-formats
type PayloadFormat int32

const (
	PayloadFormat_PAYLOAD_FORMAT_UNSPECIFIED PayloadFormat = 0 // this should never happen, can only happen if it wasn't set --> message should be rejected
	PayloadFormat_TIMESERIES                 PayloadFormat = 1 // one scalar value + timestamp (e.g. a float)
	PayloadFormat_RELATIONAL                 PayloadFormat = 2 // full JSON object (e.g. a JSON object)
)

// Enum value maps for PayloadFormat.
var (
	PayloadFormat_name = map[int32]string{
		0: "PAYLOAD_FORMAT_UNSPECIFIED",
		1: "TIMESERIES",
		2: "RELATIONAL",
	}
	PayloadFormat_value = map[string]int32{
		"PAYLOAD_FORMAT_UNSPECIFIED": 0,
		"TIMESERIES":                 1,
		"RELATIONAL":                 2,
	}
)

func (x PayloadFormat) Enum() *PayloadFormat {
	p := new(PayloadFormat)
	*p = x
	return p
}

func (x PayloadFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayloadFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_browser_data_proto_enumTypes[0].Descriptor()
}

func (PayloadFormat) Type() protoreflect.EnumType {
	return &file_topic_browser_data_proto_enumTypes[0]
}

func (x PayloadFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayloadFormat.Descriptor instead.
func (PayloadFormat) EnumDescriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{0}
}

// *
// For **TIMESERIES** payloads we also capture the scalar's *primitive* type.
// The Management Console uses this hint to pick a sensible default renderer:
//
//	NUMERIC  → plot on a line/area chart
//	STRING   → show last value in a table or status badge
//	BOOLEAN  → treat as STRING
//
// Storing the type here keeps the TimeSeriesPayload tiny and avoids costly
// JSON introspection on the front-end.
type ScalarType int32

const (
	ScalarType_SCALAR_TYPE_UNSPECIFIED ScalarType = 0 // this should never happen, can only happen if it wasn't set --> message should be rejected
	ScalarType_NUMERIC                 ScalarType = 1
	ScalarType_STRING                  ScalarType = 2
	ScalarType_BOOLEAN                 ScalarType = 3
)

// Enum value maps for ScalarType.
var (
	ScalarType_name = map[int32]string{
		0: "SCALAR_TYPE_UNSPECIFIED",
		1: "NUMERIC",
		2: "STRING",
		3: "BOOLEAN",
	}
	ScalarType_value = map[string]int32{
		"SCALAR_TYPE_UNSPECIFIED": 0,
		"NUMERIC":                 1,
		"STRING":                  2,
		"BOOLEAN":                 3,
	}
)

func (x ScalarType) Enum() *ScalarType {
	p := new(ScalarType)
	*p = x
	return p
}

func (x ScalarType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScalarType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_browser_data_proto_enumTypes[1].Descriptor()
}

func (ScalarType) Type() protoreflect.EnumType {
	return &file_topic_browser_data_proto_enumTypes[1]
}

func (x ScalarType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScalarType.Descriptor instead.
func (ScalarType) EnumDescriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{1}
}

// *
// TopicInfo breaks one UNS topic into its hierarchy levels plus a few aids for
// downstream filtering.  The FSM stores each unique TopicInfo once and refers
// to it from many events via `uns_tree_id`, saving space.
type TopicInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Physical ISA-95 (or custom) hierarchy; level0 must never be empty
	Level0 string `protobuf:"bytes,1,opt,name=level0,proto3" json:"level0,omitempty"` // e.g. "corpA"
	// Dynamic location hierarchy (level1, level2, ... levelN)
	LocationSublevels []string `protobuf:"bytes,2,rep,name=location_sublevels,json=locationSublevels,proto3" json:"location_sublevels,omitempty"` // e.g. ["plant-1", "line-4", "pump-41"]
	// Data contract that governs payload shape, e.g. "_historian"
	DataContract string `protobuf:"bytes,3,opt,name=data_contract,json=dataContract,proto3" json:"data_contract,omitempty"`
	// Optional non-physical grouping path (axis.x.position, diagnostics.*, …)
	VirtualPath *string `protobuf:"bytes,4,opt,name=virtual_path,json=virtualPath,proto3,oneof" json:"virtual_path,omitempty"` // joined with '.' if present
	// The final segment name (e.g., "temperature", "order_created")
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// Aggregated Kafka-header *metadata* for this topic.
	// ───────────────────────────────────────────────────
	//   - Every time the tag_processor sees a Kafka header on this topic it stores
	//     the *latest* value here, keyed by header name.
	//   - The map therefore holds "last known" values for headers such as
	//     `unit`, `serial_number`, `plc_address`, …—anything a bridge, PLC or
	//     stream-processor chose to add.
	//   - The front-end can search or facet by these keys without scanning live
	//     event traffic; it only needs the TopicInfo cache.
	//   - This is *not* duplicated data: EventKafka.headers (inside EventTableEntry)
	//     keeps the raw per-event headers for debugging, whereas this field is
	//     a compact, topic-level index optimised for look-ups and UI filters.
	Metadata      map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicInfo) Reset() {
	*x = TopicInfo{}
	mi := &file_topic_browser_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicInfo) ProtoMessage() {}

func (x *TopicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicInfo.ProtoReflect.Descriptor instead.
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{0}
}

func (x *TopicInfo) GetLevel0() string {
	if x != nil {
		return x.Level0
	}
	return ""
}

func (x *TopicInfo) GetLocationSublevels() []string {
	if x != nil {
		return x.LocationSublevels
	}
	return nil
}

func (x *TopicInfo) GetDataContract() string {
	if x != nil {
		return x.DataContract
	}
	return ""
}

func (x *TopicInfo) GetVirtualPath() string {
	if x != nil && x.VirtualPath != nil {
		return *x.VirtualPath
	}
	return ""
}

func (x *TopicInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TopicInfo) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// TopicMap provides a fast lookup structure for topics using their UNS Tree ID as the key.
// The UNS Tree ID is a hash of the TopicInfo fields, providing a compact unique identifier.
type TopicMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the UNS Tree id, which is a hash over the TopicInfo entries.
	// Using a hash instead of the full topic name reduces storage requirements while maintaining uniqueness.
	Entries       map[string]*TopicInfo `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicMap) Reset() {
	*x = TopicMap{}
	mi := &file_topic_browser_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicMap) ProtoMessage() {}

func (x *TopicMap) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicMap.ProtoReflect.Descriptor instead.
func (*TopicMap) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{1}
}

func (x *TopicMap) GetEntries() map[string]*TopicInfo {
	if x != nil {
		return x.Entries
	}
	return nil
}

// * Copy of the Kafka message as the tag-processor received it.
type EventKafka struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Headers       map[string]string      `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventKafka) Reset() {
	*x = EventKafka{}
	mi := &file_topic_browser_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventKafka) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventKafka) ProtoMessage() {}

func (x *EventKafka) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventKafka.ProtoReflect.Descriptor instead.
func (*EventKafka) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{2}
}

func (x *EventKafka) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *EventKafka) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// *
// TimeSeriesPayload  ─ the canonical UMH "one-tag / one-value" shape
// ---------------------------------------------------------------
//   - Holds exactly one scalar *and* the moment it was observed at the source.
//   - `scalar_type` mirrors the ScalarType enum so the UI can decide quickly
//     whether the value should be plotted (numeric), shown as text (string) or
//     rendered as a state indicator (boolean).
//   - `value` is a oneof containing standard protobuf wrapper types:
//     ▸ google.protobuf.DoubleValue   → NUMERIC
//     ▸ google.protobuf.StringValue   → STRING
//     ▸ google.protobuf.BoolValue     → BOOLEAN
//   - `timestamp_ms` is the **source** timestamp (epoch-ms).  It describes when
//     the PLC / device generated the value, *not* when Kafka wrote the message.
//     The latter lives in `EventTableEntry.produced_at_ms` for debugging.
type TimeSeriesPayload struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	ScalarType ScalarType             `protobuf:"varint,1,opt,name=scalar_type,json=scalarType,proto3,enum=umh.topic.proto.ScalarType" json:"scalar_type,omitempty"` // numeric / string / boolean (for frontend convenience)
	// Types that are valid to be assigned to Value:
	//
	//	*TimeSeriesPayload_NumericValue
	//	*TimeSeriesPayload_StringValue
	//	*TimeSeriesPayload_BooleanValue
	Value         isTimeSeriesPayload_Value `protobuf_oneof:"value"`
	TimestampMs   int64                     `protobuf:"varint,5,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"` // source time
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimeSeriesPayload) Reset() {
	*x = TimeSeriesPayload{}
	mi := &file_topic_browser_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeSeriesPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeSeriesPayload) ProtoMessage() {}

func (x *TimeSeriesPayload) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeSeriesPayload.ProtoReflect.Descriptor instead.
func (*TimeSeriesPayload) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{3}
}

func (x *TimeSeriesPayload) GetScalarType() ScalarType {
	if x != nil {
		return x.ScalarType
	}
	return ScalarType_SCALAR_TYPE_UNSPECIFIED
}

func (x *TimeSeriesPayload) GetValue() isTimeSeriesPayload_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TimeSeriesPayload) GetNumericValue() *wrapperspb.DoubleValue {
	if x != nil {
		if x, ok := x.Value.(*TimeSeriesPayload_NumericValue); ok {
			return x.NumericValue
		}
	}
	return nil
}

func (x *TimeSeriesPayload) GetStringValue() *wrapperspb.StringValue {
	if x != nil {
		if x, ok := x.Value.(*TimeSeriesPayload_StringValue); ok {
			return x.StringValue
		}
	}
	return nil
}

func (x *TimeSeriesPayload) GetBooleanValue() *wrapperspb.BoolValue {
	if x != nil {
		if x, ok := x.Value.(*TimeSeriesPayload_BooleanValue); ok {
			return x.BooleanValue
		}
	}
	return nil
}

func (x *TimeSeriesPayload) GetTimestampMs() int64 {
	if x != nil {
		return x.TimestampMs
	}
	return 0
}

type isTimeSeriesPayload_Value interface {
	isTimeSeriesPayload_Value()
}

type TimeSeriesPayload_NumericValue struct {
	NumericValue *wrapperspb.DoubleValue `protobuf:"bytes,2,opt,name=numeric_value,json=numericValue,proto3,oneof"` // NUMERIC values
}

type TimeSeriesPayload_StringValue struct {
	StringValue *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=string_value,json=stringValue,proto3,oneof"` // STRING values
}

type TimeSeriesPayload_BooleanValue struct {
	BooleanValue *wrapperspb.BoolValue `protobuf:"bytes,4,opt,name=boolean_value,json=booleanValue,proto3,oneof"` // BOOLEAN values
}

func (*TimeSeriesPayload_NumericValue) isTimeSeriesPayload_Value() {}

func (*TimeSeriesPayload_StringValue) isTimeSeriesPayload_Value() {}

func (*TimeSeriesPayload_BooleanValue) isTimeSeriesPayload_Value() {}

// *
// RelationalPayload  ─ full JSON document shape
// ---------------------------------------------
//   - Used when an event already bundles multiple related fields (order header,
//     batch summary, set-point list, …) that *belong together*.
//   - Payload arrives as valid UTF-8 JSON bytes; no extra framing or base64.
//   - Downstream processors are free to validate this blob against the data
//     contract referenced in TopicInfo.data_contract.
type RelationalPayload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Json          []byte                 `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"` // already UTF-8 JSON bytes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationalPayload) Reset() {
	*x = RelationalPayload{}
	mi := &file_topic_browser_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationalPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationalPayload) ProtoMessage() {}

func (x *RelationalPayload) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationalPayload.ProtoReflect.Descriptor instead.
func (*RelationalPayload) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{4}
}

func (x *RelationalPayload) GetJson() []byte {
	if x != nil {
		return x.Json
	}
	return nil
}

// *
// EventTableEntry – one *normalised* UNS event
// -------------------------------------------
// The tag-processor converts every raw Kafka record into exactly one of these
// entries and drops it into the ring-buffer that later becomes
// UnsBundle.events[*].
//
// Why the split?
//   - **TopicInfo** (in UnsBundle.uns_map) describes the *where* and *what* of
//     the signal and changes rarely.
//   - **EventTableEntry** carries the *latest value* plus a few breadcrumbs
//     that make troubleshooting painless.
//
// Field-by-field rundown
// ──────────────────────
// uns_tree_id      – 64-bit xxHash of the TopicInfo.  Lets the Frontend join the
//
//	payload back to its TopicInfo without repeating long
//	strings in every row.
//
// payload_format   – PayloadFormat enum for frontend convenience. Allows UI to
//
//	quickly determine if this is TIMESERIES or RELATIONAL data
//	without inspecting the oneof payload structure.
//
// payload          – `oneof` branch holding either:
//
//	▸ TimeSeriesPayload  (scalar + timestamp_ms)
//	▸ RelationalPayload  (full JSON document)
//
// raw_kafka_msg    – Exact copy of the message *before* the tag-processor
//
//	touched it (headers + value only).  Included **solely**
//	for deep debugging, packet captures, etc.  Normal runtime
//	logic should ignore it.
//
// bridged_by       – Ordered list of Benthos instances the record traversed.
//
//	Helpful when chains of bridges reshape or forward the same topic multiple times to get the trace of the record.
//
// produced_at_ms   – Kafka's own timestamp (epoch-ms) when the record was
//
//	written to the UNS.  Use this to spot buffering or
//	network latency.  Do *not* confuse with
//	TimeSeriesPayload.timestamp_ms, which is the **source**
//	time inside the PLC/device.
type EventTableEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsTreeId     string                 `protobuf:"bytes,1,opt,name=uns_tree_id,json=unsTreeId,proto3" json:"uns_tree_id,omitempty"`                                               // xxHash over TopicInfo
	PayloadFormat PayloadFormat          `protobuf:"varint,2,opt,name=payload_format,json=payloadFormat,proto3,enum=umh.topic.proto.PayloadFormat" json:"payload_format,omitempty"` // TIMESERIES/RELATIONAL (frontend convenience)
	// Fields 3,4 reserved for future metadata expansion
	RawKafkaMsg  *EventKafka `protobuf:"bytes,5,opt,name=raw_kafka_msg,json=rawKafkaMsg,proto3" json:"raw_kafka_msg,omitempty"`     // headers + value, for debugging
	BridgedBy    []string    `protobuf:"bytes,6,rep,name=bridged_by,json=bridgedBy,proto3" json:"bridged_by,omitempty"`             // Benthos hops (oldest → newest)
	ProducedAtMs uint64      `protobuf:"varint,7,opt,name=produced_at_ms,json=producedAtMs,proto3" json:"produced_at_ms,omitempty"` // Kafka write time, epoch-ms
	// Fields 8,9 reserved for future expansion
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*EventTableEntry_Ts
	//	*EventTableEntry_Rel
	Payload       isEventTableEntry_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTableEntry) Reset() {
	*x = EventTableEntry{}
	mi := &file_topic_browser_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTableEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTableEntry) ProtoMessage() {}

func (x *EventTableEntry) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTableEntry.ProtoReflect.Descriptor instead.
func (*EventTableEntry) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{5}
}

func (x *EventTableEntry) GetUnsTreeId() string {
	if x != nil {
		return x.UnsTreeId
	}
	return ""
}

func (x *EventTableEntry) GetPayloadFormat() PayloadFormat {
	if x != nil {
		return x.PayloadFormat
	}
	return PayloadFormat_PAYLOAD_FORMAT_UNSPECIFIED
}

func (x *EventTableEntry) GetRawKafkaMsg() *EventKafka {
	if x != nil {
		return x.RawKafkaMsg
	}
	return nil
}

func (x *EventTableEntry) GetBridgedBy() []string {
	if x != nil {
		return x.BridgedBy
	}
	return nil
}

func (x *EventTableEntry) GetProducedAtMs() uint64 {
	if x != nil {
		return x.ProducedAtMs
	}
	return 0
}

func (x *EventTableEntry) GetPayload() isEventTableEntry_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *EventTableEntry) GetTs() *TimeSeriesPayload {
	if x != nil {
		if x, ok := x.Payload.(*EventTableEntry_Ts); ok {
			return x.Ts
		}
	}
	return nil
}

func (x *EventTableEntry) GetRel() *RelationalPayload {
	if x != nil {
		if x, ok := x.Payload.(*EventTableEntry_Rel); ok {
			return x.Rel
		}
	}
	return nil
}

type isEventTableEntry_Payload interface {
	isEventTableEntry_Payload()
}

type EventTableEntry_Ts struct {
	Ts *TimeSeriesPayload `protobuf:"bytes,10,opt,name=ts,proto3,oneof"`
}

type EventTableEntry_Rel struct {
	Rel *RelationalPayload `protobuf:"bytes,11,opt,name=rel,proto3,oneof"`
}

func (*EventTableEntry_Ts) isEventTableEntry_Payload() {}

func (*EventTableEntry_Rel) isEventTableEntry_Payload() {}

// EventTable contains a batch of processed events.
type EventTable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       []*EventTableEntry     `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventTable) Reset() {
	*x = EventTable{}
	mi := &file_topic_browser_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTable) ProtoMessage() {}

func (x *EventTable) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventTable.ProtoReflect.Descriptor instead.
func (*EventTable) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{6}
}

func (x *EventTable) GetEntries() []*EventTableEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// *
// A single frame delivered to the FSM:
//   - `uns_map`  – the full TopicInfo map
//   - `events`   – matching EventTable entries
type UnsBundle struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UnsMap        *TopicMap              `protobuf:"bytes,1,opt,name=uns_map,json=unsMap,proto3" json:"uns_map,omitempty"` // Map of all topics if new or changed topics or a metadata was changed
	Events        *EventTable            `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`               // Events associated with these topics
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsBundle) Reset() {
	*x = UnsBundle{}
	mi := &file_topic_browser_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsBundle) ProtoMessage() {}

func (x *UnsBundle) ProtoReflect() protoreflect.Message {
	mi := &file_topic_browser_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsBundle.ProtoReflect.Descriptor instead.
func (*UnsBundle) Descriptor() ([]byte, []int) {
	return file_topic_browser_data_proto_rawDescGZIP(), []int{7}
}

func (x *UnsBundle) GetUnsMap() *TopicMap {
	if x != nil {
		return x.UnsMap
	}
	return nil
}

func (x *UnsBundle) GetEvents() *EventTable {
	if x != nil {
		return x.Events
	}
	return nil
}

var File_topic_browser_data_proto protoreflect.FileDescriptor

const file_topic_browser_data_proto_rawDesc = "" +
	"\n" +
	"\x18topic_browser_data.proto\x12\x0fumh.topic.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xc7\x02\n" +
	"\tTopicInfo\x12\x16\n" +
	"\x06level0\x18\x01 \x01(\tR\x06level0\x12-\n" +
	"\x12location_sublevels\x18\x02 \x03(\tR\x11locationSublevels\x12#\n" +
	"\rdata_contract\x18\x03 \x01(\tR\fdataContract\x12&\n" +
	"\fvirtual_path\x18\x04 \x01(\tH\x00R\vvirtualPath\x88\x01\x01\x12\x12\n" +
	"\x04name\x18\x05 \x01(\tR\x04name\x12D\n" +
	"\bmetadata\x18\x06 \x03(\v2(.umh.topic.proto.TopicInfo.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x0f\n" +
	"\r_virtual_path\"\xa4\x01\n" +
	"\bTopicMap\x12@\n" +
	"\aentries\x18\x01 \x03(\v2&.umh.topic.proto.TopicMap.EntriesEntryR\aentries\x1aV\n" +
	"\fEntriesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.umh.topic.proto.TopicInfoR\x05value:\x028\x01\"\xa6\x01\n" +
	"\n" +
	"EventKafka\x12B\n" +
	"\aheaders\x18\x01 \x03(\v2(.umh.topic.proto.EventKafka.HeadersEntryR\aheaders\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc8\x02\n" +
	"\x11TimeSeriesPayload\x12<\n" +
	"\vscalar_type\x18\x01 \x01(\x0e2\x1b.umh.topic.proto.ScalarTypeR\n" +
	"scalarType\x12C\n" +
	"\rnumeric_value\x18\x02 \x01(\v2\x1c.google.protobuf.DoubleValueH\x00R\fnumericValue\x12A\n" +
	"\fstring_value\x18\x03 \x01(\v2\x1c.google.protobuf.StringValueH\x00R\vstringValue\x12A\n" +
	"\rboolean_value\x18\x04 \x01(\v2\x1a.google.protobuf.BoolValueH\x00R\fbooleanValue\x12!\n" +
	"\ftimestamp_ms\x18\x05 \x01(\x03R\vtimestampMsB\a\n" +
	"\x05value\"'\n" +
	"\x11RelationalPayload\x12\x12\n" +
	"\x04json\x18\x01 \x01(\fR\x04json\"\xf7\x02\n" +
	"\x0fEventTableEntry\x12\x1e\n" +
	"\vuns_tree_id\x18\x01 \x01(\tR\tunsTreeId\x12E\n" +
	"\x0epayload_format\x18\x02 \x01(\x0e2\x1e.umh.topic.proto.PayloadFormatR\rpayloadFormat\x12?\n" +
	"\rraw_kafka_msg\x18\x05 \x01(\v2\x1b.umh.topic.proto.EventKafkaR\vrawKafkaMsg\x12\x1d\n" +
	"\n" +
	"bridged_by\x18\x06 \x03(\tR\tbridgedBy\x12$\n" +
	"\x0eproduced_at_ms\x18\a \x01(\x04R\fproducedAtMs\x124\n" +
	"\x02ts\x18\n" +
	" \x01(\v2\".umh.topic.proto.TimeSeriesPayloadH\x00R\x02ts\x126\n" +
	"\x03rel\x18\v \x01(\v2\".umh.topic.proto.RelationalPayloadH\x00R\x03relB\t\n" +
	"\apayload\"H\n" +
	"\n" +
	"EventTable\x12:\n" +
	"\aentries\x18\x01 \x03(\v2 .umh.topic.proto.EventTableEntryR\aentries\"t\n" +
	"\tUnsBundle\x122\n" +
	"\auns_map\x18\x01 \x01(\v2\x19.umh.topic.proto.TopicMapR\x06unsMap\x123\n" +
	"\x06events\x18\x02 \x01(\v2\x1b.umh.topic.proto.EventTableR\x06events*O\n" +
	"\rPayloadFormat\x12\x1e\n" +
	"\x1aPAYLOAD_FORMAT_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"TIMESERIES\x10\x01\x12\x0e\n" +
	"\n" +
	"RELATIONAL\x10\x02*O\n" +
	"\n" +
	"ScalarType\x12\x1b\n" +
	"\x17SCALAR_TYPE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aNUMERIC\x10\x01\x12\n" +
	"\n" +
	"\x06STRING\x10\x02\x12\v\n" +
	"\aBOOLEAN\x10\x03B\tZ\a.;protob\x06proto3"

var (
	file_topic_browser_data_proto_rawDescOnce sync.Once
	file_topic_browser_data_proto_rawDescData []byte
)

func file_topic_browser_data_proto_rawDescGZIP() []byte {
	file_topic_browser_data_proto_rawDescOnce.Do(func() {
		file_topic_browser_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topic_browser_data_proto_rawDesc), len(file_topic_browser_data_proto_rawDesc)))
	})
	return file_topic_browser_data_proto_rawDescData
}

var file_topic_browser_data_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_topic_browser_data_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_topic_browser_data_proto_goTypes = []any{
	(PayloadFormat)(0),             // 0: umh.topic.proto.PayloadFormat
	(ScalarType)(0),                // 1: umh.topic.proto.ScalarType
	(*TopicInfo)(nil),              // 2: umh.topic.proto.TopicInfo
	(*TopicMap)(nil),               // 3: umh.topic.proto.TopicMap
	(*EventKafka)(nil),             // 4: umh.topic.proto.EventKafka
	(*TimeSeriesPayload)(nil),      // 5: umh.topic.proto.TimeSeriesPayload
	(*RelationalPayload)(nil),      // 6: umh.topic.proto.RelationalPayload
	(*EventTableEntry)(nil),        // 7: umh.topic.proto.EventTableEntry
	(*EventTable)(nil),             // 8: umh.topic.proto.EventTable
	(*UnsBundle)(nil),              // 9: umh.topic.proto.UnsBundle
	nil,                            // 10: umh.topic.proto.TopicInfo.MetadataEntry
	nil,                            // 11: umh.topic.proto.TopicMap.EntriesEntry
	nil,                            // 12: umh.topic.proto.EventKafka.HeadersEntry
	(*wrapperspb.DoubleValue)(nil), // 13: google.protobuf.DoubleValue
	(*wrapperspb.StringValue)(nil), // 14: google.protobuf.StringValue
	(*wrapperspb.BoolValue)(nil),   // 15: google.protobuf.BoolValue
}
var file_topic_browser_data_proto_depIdxs = []int32{
	10, // 0: umh.topic.proto.TopicInfo.metadata:type_name -> umh.topic.proto.TopicInfo.MetadataEntry
	11, // 1: umh.topic.proto.TopicMap.entries:type_name -> umh.topic.proto.TopicMap.EntriesEntry
	12, // 2: umh.topic.proto.EventKafka.headers:type_name -> umh.topic.proto.EventKafka.HeadersEntry
	1,  // 3: umh.topic.proto.TimeSeriesPayload.scalar_type:type_name -> umh.topic.proto.ScalarType
	13, // 4: umh.topic.proto.TimeSeriesPayload.numeric_value:type_name -> google.protobuf.DoubleValue
	14, // 5: umh.topic.proto.TimeSeriesPayload.string_value:type_name -> google.protobuf.StringValue
	15, // 6: umh.topic.proto.TimeSeriesPayload.boolean_value:type_name -> google.protobuf.BoolValue
	0,  // 7: umh.topic.proto.EventTableEntry.payload_format:type_name -> umh.topic.proto.PayloadFormat
	4,  // 8: umh.topic.proto.EventTableEntry.raw_kafka_msg:type_name -> umh.topic.proto.EventKafka
	5,  // 9: umh.topic.proto.EventTableEntry.ts:type_name -> umh.topic.proto.TimeSeriesPayload
	6,  // 10: umh.topic.proto.EventTableEntry.rel:type_name -> umh.topic.proto.RelationalPayload
	7,  // 11: umh.topic.proto.EventTable.entries:type_name -> umh.topic.proto.EventTableEntry
	3,  // 12: umh.topic.proto.UnsBundle.uns_map:type_name -> umh.topic.proto.TopicMap
	8,  // 13: umh.topic.proto.UnsBundle.events:type_name -> umh.topic.proto.EventTable
	2,  // 14: umh.topic.proto.TopicMap.EntriesEntry.value:type_name -> umh.topic.proto.TopicInfo
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_topic_browser_data_proto_init() }
func file_topic_browser_data_proto_init() {
	if File_topic_browser_data_proto != nil {
		return
	}
	file_topic_browser_data_proto_msgTypes[0].OneofWrappers = []any{}
	file_topic_browser_data_proto_msgTypes[3].OneofWrappers = []any{
		(*TimeSeriesPayload_NumericValue)(nil),
		(*TimeSeriesPayload_StringValue)(nil),
		(*TimeSeriesPayload_BooleanValue)(nil),
	}
	file_topic_browser_data_proto_msgTypes[5].OneofWrappers = []any{
		(*EventTableEntry_Ts)(nil),
		(*EventTableEntry_Rel)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topic_browser_data_proto_rawDesc), len(file_topic_browser_data_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topic_browser_data_proto_goTypes,
		DependencyIndexes: file_topic_browser_data_proto_depIdxs,
		EnumInfos:         file_topic_browser_data_proto_enumTypes,
		MessageInfos:      file_topic_browser_data_proto_msgTypes,
	}.Build()
	File_topic_browser_data_proto = out.File
	file_topic_browser_data_proto_goTypes = nil
	file_topic_browser_data_proto_depIdxs = nil
}
