// Copyright 2025 UMH Systems GmbH
package supervisor_test

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/umh-core/pkg/fsmv2"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/umh-core/pkg/fsmv2/container"
	"github.com/united-manufacturing-hub/united-manufacturing-hub/umh-core/pkg/fsmv2/supervisor"
	"go.uber.org/zap"
)

var _ = Describe("Edge Cases", func() {
	Describe("FreshnessChecker edge cases", func() {
		Context("when snapshot has nil observed state", func() {
			It("should return false for Check", func() {
				checker := supervisor.NewFreshnessChecker(
					10*time.Second,
					20*time.Second,
					zap.NewNop().Sugar(),
				)

				snapshot := fsmv2.Snapshot{
					Identity: mockIdentity(),
					Observed: nil,
					Desired:  &container.ContainerDesiredState{},
				}

				Expect(checker.Check(snapshot)).To(BeFalse())
			})

			It("should return false for IsTimeout", func() {
				checker := supervisor.NewFreshnessChecker(
					10*time.Second,
					20*time.Second,
					zap.NewNop().Sugar(),
				)

				snapshot := fsmv2.Snapshot{
					Identity: mockIdentity(),
					Observed: nil,
					Desired:  &container.ContainerDesiredState{},
				}

				Expect(checker.IsTimeout(snapshot)).To(BeFalse())
			})
		})
	})

	Describe("Collector error handling", func() {
		Context("when CollectObservedState fails", func() {
			It("should continue observation loop", func() {
				var callCountMutex sync.Mutex
				callCount := 0
				collector := supervisor.NewCollector(supervisor.CollectorConfig{
					Worker: &mockWorker{
						collectFunc: func(ctx context.Context) (fsmv2.ObservedState, error) {
							callCountMutex.Lock()
							callCount++
							count := callCount
							callCountMutex.Unlock()

							if count == 1 {
								return nil, errors.New("collection error")
							}

							return &container.ContainerObservedState{CollectedAt: time.Now()}, nil
						},
					},
					Identity:            mockIdentity(),
					Logger:              zap.NewNop().Sugar(),
					ObservationInterval: 50 * time.Millisecond,
					ObservationTimeout:  1 * time.Second,
				})

				ctx, cancel := context.WithCancel(context.Background())
				defer cancel()

				err := collector.Start(ctx)
				Expect(err).ToNot(HaveOccurred())

				time.Sleep(200 * time.Millisecond)

				callCountMutex.Lock()
				finalCount := callCount
				callCountMutex.Unlock()
				Expect(finalCount).To(BeNumerically(">=", 2))

				cancel()
				time.Sleep(100 * time.Millisecond)
			})
		})

		Context("when SaveObserved fails", func() {
			It("should continue observation loop", func() {
				var saveCallCountMutex sync.Mutex
				saveCallCount := 0

				collector := supervisor.NewCollector(supervisor.CollectorConfig{
					Worker: &mockWorker{
						collectFunc: func(ctx context.Context) (fsmv2.ObservedState, error) {
							saveCallCountMutex.Lock()
							saveCallCount++
							saveCallCountMutex.Unlock()

							return &container.ContainerObservedState{CollectedAt: time.Now()}, nil
						},
					},
					Identity:            mockIdentity(),
					Logger:              zap.NewNop().Sugar(),
					ObservationInterval: 50 * time.Millisecond,
					ObservationTimeout:  1 * time.Second,
				})

				ctx, cancel := context.WithCancel(context.Background())
				defer cancel()

				err := collector.Start(ctx)
				Expect(err).ToNot(HaveOccurred())

				time.Sleep(200 * time.Millisecond)

				saveCallCountMutex.Lock()
				finalSaveCount := saveCallCount
				saveCallCountMutex.Unlock()
				Expect(finalSaveCount).To(BeNumerically(">=", 2))

				cancel()
				time.Sleep(100 * time.Millisecond)
			})
		})

		Context("when context is canceled during collection", func() {
			It("should stop observation loop", func() {
				collector := supervisor.NewCollector(supervisor.CollectorConfig{
					Worker:              &mockWorker{},
					Identity:            mockIdentity(),
					Logger:              zap.NewNop().Sugar(),
					ObservationInterval: 1 * time.Second,
					ObservationTimeout:  3 * time.Second,
				})

				ctx, cancel := context.WithCancel(context.Background())

				err := collector.Start(ctx)
				Expect(err).ToNot(HaveOccurred())

				time.Sleep(50 * time.Millisecond)
				Expect(collector.IsRunning()).To(BeTrue())

				cancel()

				Eventually(func() bool {
					return collector.IsRunning()
				}, 2*time.Second).Should(BeFalse())
			})
		})

		Context("when Restart is called with pending restart", func() {
			It("should not block", func() {
				collector := supervisor.NewCollector(supervisor.CollectorConfig{
					Worker:              &mockWorker{},
					Identity:            mockIdentity(),
					Logger:              zap.NewNop().Sugar(),
					ObservationInterval: 1 * time.Second,
					ObservationTimeout:  3 * time.Second,
				})

				ctx, cancel := context.WithCancel(context.Background())
				defer cancel()

				err := collector.Start(ctx)
				Expect(err).ToNot(HaveOccurred())

				collector.Restart()
				collector.Restart()

				time.Sleep(100 * time.Millisecond)

				cancel()
			})
		})
	})

	Describe("Supervisor signal processing", func() {
		Context("when signal is SignalNone", func() {
			It("should process normally", func() {

				initialState := &mockState{signal: fsmv2.SignalNone}

				s := newSupervisorWithWorker(&mockWorker{initialState: initialState}, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
			})
		})
	})

	Describe("RequestShutdown", func() {
		Context("when shutdown is requested", func() {
			It("should save desired state with shutdown flag", func() {
				savedDesired := false

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{})

				err := s.RequestShutdown(context.Background(), "test-worker", "test reason")
				Expect(err).ToNot(HaveOccurred())
				Expect(savedDesired).To(BeTrue())
			})
		})

		Context("when SaveDesired fails", func() {
			It("should return error", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{})

				err := s.RequestShutdown(context.Background(), "test-worker", "test reason")
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed to save desired state"))
			})
		})
	})

	Describe("Action execution with retry", func() {
		Context("when action succeeds on first try", func() {
			It("should execute without retry", func() {
				callCount := 0
				action := &mockAction{
					executeFunc: func(ctx context.Context) error {
						callCount++

						return nil
					},
				}


				initialState := &mockState{}
				initialState.nextState = initialState
				initialState.action = action

				s := newSupervisorWithWorker(&mockWorker{initialState: initialState}, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
				Expect(callCount).To(Equal(1))
			})
		})

		Context("when action fails once then succeeds", func() {
			It("should retry and succeed", func() {
				callCount := 0
				action := &mockAction{
					executeFunc: func(ctx context.Context) error {
						callCount++
						if callCount == 1 {
							return errors.New("temporary error")
						}

						return nil
					},
				}


				initialState := &mockState{}
				initialState.nextState = initialState
				initialState.action = action

				s := newSupervisorWithWorker(&mockWorker{initialState: initialState}, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
				Expect(callCount).To(Equal(2))
			})
		})

		Context("when action always fails", func() {
			It("should retry max times then fail", func() {
				callCount := 0
				action := &mockAction{
					executeFunc: func(ctx context.Context) error {
						callCount++

						return errors.New("persistent error")
					},
				}


				initialState := &mockState{}
				initialState.nextState = initialState
				initialState.action = action

				s := newSupervisorWithWorker(&mockWorker{initialState: initialState}, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed after"))
				Expect(callCount).To(Equal(3))
			})
		})
	})

	Describe("Tick timeout handling", func() {
		Context("when data times out and restart count is below max", func() {
			It("should restart collector", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{
					StaleThreshold:     10 * time.Second,
					Timeout:            20 * time.Second,
					MaxRestartAttempts: 3,
				})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
				Expect(s.GetRestartCount()).To(Equal(1))
			})
		})

		Context("when data times out and restart count is at max", func() {
			It("should request shutdown", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{
					StaleThreshold:     10 * time.Second,
					Timeout:            20 * time.Second,
					MaxRestartAttempts: 3,
				})

				s.SetRestartCount(3)

				err := s.Tick(context.Background())
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("unresponsive"))
			})
		})

		Context("when collector recovers after restarts", func() {
			It("should reset restart count", func() {
				store := &mockStore{}

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{})

				s.SetRestartCount(2)

				store.snapshot = fsmv2.Snapshot{
					Identity: mockIdentity(),
					Desired:  &container.ContainerDesiredState{},
					Observed: &container.ContainerObservedState{CollectedAt: time.Now()},
				}

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
				Expect(s.GetRestartCount()).To(Equal(0))
			})
		})
	})

	Describe("Tick LoadSnapshot error handling", func() {
		Context("when LoadSnapshot fails", func() {
			It("should return error", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed to load snapshot"))
			})
		})
	})

	Describe("Context cancellation", func() {
		Context("when context is canceled during tick loop", func() {
			It("should stop tick loop gracefully", func() {
				s := supervisor.NewSupervisor(supervisor.Config{
					WorkerType:   "container",
					Logger:       zap.NewNop().Sugar(),
					TickInterval: 100 * time.Millisecond,
				})

				identity := mockIdentity()
				worker := &mockWorker{}
				err := s.AddWorker(identity, worker)
				Expect(err).ToNot(HaveOccurred())

				ctx, cancel := context.WithCancel(context.Background())

				done := s.Start(ctx)

				time.Sleep(50 * time.Millisecond)

				cancel()

				Eventually(done, 2*time.Second).Should(BeClosed())
			})
		})

		Context("when context is canceled before first tick", func() {
			It("should stop immediately", func() {
				s := supervisor.NewSupervisor(supervisor.Config{
					WorkerType:   "container",
					Logger:       zap.NewNop().Sugar(),
					TickInterval: 5 * time.Second,
				})

				identity := mockIdentity()
				worker := &mockWorker{}
				err := s.AddWorker(identity, worker)
				Expect(err).ToNot(HaveOccurred())

				ctx, cancel := context.WithCancel(context.Background())
				cancel()

				done := s.Start(ctx)

				Eventually(done, 1*time.Second).Should(BeClosed())
			})
		})
	})

	Describe("RequestShutdown LoadDesired error", func() {
		Context("when LoadDesired fails", func() {
			It("should return error", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{})

				err := s.RequestShutdown(context.Background(), "test-worker", "test reason")
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed to load desired state"))
			})
		})
	})

	Describe("Shutdown escalation with SaveDesired error", func() {
		Context("when max restart attempts reached and SaveDesired fails", func() {
			It("should log error and return shutdown error", func() {
				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{
					StaleThreshold:     10 * time.Second,
					Timeout:            20 * time.Second,
					MaxRestartAttempts: 3,
				})

				s.SetRestartCount(3)

				err := s.Tick(context.Background())
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("unresponsive"))
			})
		})
	})

	Describe("Stale data pausing FSM", func() {
		Context("when data is stale but not timed out", func() {
			It("should pause FSM without restarting collector", func() {

				s := newSupervisorWithWorker(&mockWorker{}, supervisor.CollectorHealthConfig{
					StaleThreshold:     10 * time.Second,
					Timeout:            20 * time.Second,
					MaxRestartAttempts: 3,
				})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
				Expect(s.GetRestartCount()).To(Equal(0))
			})
		})
	})
})

type mockAction struct {
	executeFunc func(ctx context.Context) error
	name        string
}

func (m *mockAction) Execute(ctx context.Context) error {
	if m.executeFunc != nil {
		return m.executeFunc(ctx)
	}

	return nil
}

func (m *mockAction) Name() string {
	if m.name != "" {
		return m.name
	}

	return "MockAction"
}

type alternateObservedState struct {
	timestamp time.Time
}

func (a *alternateObservedState) GetTimestamp() time.Time { return a.timestamp }
func (a *alternateObservedState) ShutdownRequested() bool { return false }
func (a *alternateObservedState) GetObservedDesiredState() fsmv2.DesiredState {
	return &container.ContainerDesiredState{}
}

var _ = Describe("Type Safety (Invariant I16)", func() {
	Describe("ObservedState type validation", func() {
		Context("when worker returns wrong ObservedState type", func() {
			It("should panic with clear message before calling state.Next()", func() {
				callCount := 0
				store := &mockStore{}

				worker := &mockWorker{
					collectFunc: func(ctx context.Context) (fsmv2.ObservedState, error) {
						callCount++
						if callCount == 1 {
							return &container.ContainerObservedState{CollectedAt: time.Now()}, nil
						}

						return &alternateObservedState{timestamp: time.Now()}, nil
					},
				}

				s := newSupervisorWithWorker(worker, supervisor.CollectorHealthConfig{})

				store.snapshot = fsmv2.Snapshot{
					Identity: mockIdentity(),
					Desired:  &container.ContainerDesiredState{},
					Observed: &alternateObservedState{timestamp: time.Now()},
				}

				var panicMessage string
				func() {
					defer func() {
						if r := recover(); r != nil {
							panicMessage = r.(string)
						}
					}()
					_ = s.Tick(context.Background())
				}()

				Expect(panicMessage).To(ContainSubstring("Invariant I16 violated"))
				Expect(panicMessage).To(ContainSubstring("test-worker"))
				Expect(panicMessage).To(ContainSubstring("alternateObservedState"))
				Expect(panicMessage).To(ContainSubstring("ContainerObservedState"))
			})
		})

		Context("when worker returns nil ObservedState", func() {
			It("should panic with clear message before calling state.Next()", func() {
				worker := &mockWorker{
					collectFunc: func(ctx context.Context) (fsmv2.ObservedState, error) {
						return &container.ContainerObservedState{CollectedAt: time.Now()}, nil
					},
				}


				s := newSupervisorWithWorker(worker, supervisor.CollectorHealthConfig{})

				var panicMessage string
				func() {
					defer func() {
						if r := recover(); r != nil {
							panicMessage = fmt.Sprintf("%v", r)
						}
					}()
					_ = s.Tick(context.Background())
				}()

				Expect(panicMessage).To(ContainSubstring("Invariant I16 violated"))
				Expect(panicMessage).To(ContainSubstring("nil ObservedState"))
				Expect(panicMessage).To(ContainSubstring("test-worker"))
			})
		})

		Context("when worker consistently returns correct type", func() {
			It("should not panic", func() {

				worker := &mockWorker{
					observed: &container.ContainerObservedState{CollectedAt: time.Now()},
				}

				s := newSupervisorWithWorker(worker, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
			})
		})

		Context("when worker returns pointer type consistently (I16 normalization test)", func() {
			It("should not panic due to pointer vs struct type mismatch", func() {
				worker := &mockWorker{
					observed: &container.ContainerObservedState{CollectedAt: time.Now()},
				}

				s := newSupervisorWithWorker(worker, supervisor.CollectorHealthConfig{})

				err := s.Tick(context.Background())
				Expect(err).ToNot(HaveOccurred())
			})
		})
	})
})
